### 1. 스프링 프로젝트 기본 구조 및 실행 과정

#### **스프링 프로젝트 기본 구조**

![image](https://user-images.githubusercontent.com/64416833/141065916-fa6fca38-ccee-4b60-aec7-b7c35d6b6836.png)

1. web.xml
2. root-context.xml / servlet-conext.xml load
3. servlet-context에 명시된 controller address mapping
4. Controller 내부 메서드 실행<br><br>

* web.xml (서블릿 배포 기술자, DD(Deployment Descriptor))
    - WAS(Tomcat)가 최초로 구동될 때 WEB-INF/ 디렉터리에 존재하는 web.xml을 읽고 그에 해당하는 웹 애플리케이션 설정을 구성한다. 
    <br>다시 말해, **각종 설정을 위한 설정파일**이다.<br>
    - 여러 xml파일(기본 : root-context.xml / servlet-context.xml)을 인식하도록 각 파일을 가리켜준다

```
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
 
 <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
 <context-param>
 <param-name>contextConfigLocation</param-name>
 <param-value>/WEB-INF/spring/root-context.xml</param-value>
 </context-param>
 
 <!-- Creates the Spring Container shared by all Servlets and Filters -->
 <listener>
 <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
 </listener>
 
 <!-- Processes application requests -->
 <servlet>
 <servlet-name>appServlet</servlet-name>
 <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
 <init-param>
 <param-name>contextConfigLocation</param-name>
 <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
 </init-param>
 <load-on-startup>1</load-on-startup>
 </servlet>
 
 <servlet-mapping>
 <servlet-name>appServlet</servlet-name>
 <url-pattern>/</url-pattern>
 </servlet-mapping>
</web-app>
```

각 태그의 세부내용은 다음과 같다.

`<servlet>` : DispatcherServlet을 구현하기 위해 어떤 클래스를 이용해야 할지와 초기 파라미터 정보를 포함하고 있다. <br>
`<servlet-name>` : 해당 서블렛의 이름을 지정하면 이 지정된 이름을 가지고 다른 설정 파일에서 해당 서블릿 정보를 참조한다. <br>
`<servlet-class>` : 어떤 클래스를 가지고 DispatcherServlet을 구현할 것인지를 명시하고 있다. <br>
`<init-param>`  : 초기화 파라미터에 대한 정보. servlet에 대한 설정 정보가 여기에 들어간다. 만약 초기화 파라미터에 대한 정보를 기술하지 않을 경우 스프링이 자동적으로 appServlet-context.xml을 이용하여 스프링 컨테이너를 생성한다. <br>
`<load-on-startup>` :  서블릿이 로딩될 때 로딩 순서를 결정하는 값. 톰캣이 구동되고 서블릿이 로딩되기 전 해당 서블릿에 요청이 들어오면 서블릿이 구동되기 전까지 기다려야 한다. 이 중 우선순위가 높은 서블릿부터 구동할 때 쓰이는 값이다. <br>
`<servlet-mapping>` : 서블렛이 <url-pattern>에서 지정한 패턴으로 클라이언트 요청이 들어오면 해당 <servlet-name>을 가진 servlet에게 이 요청을 토스하는 정보를 기술한다. <br>



* servlet-context.xml
    - 서블릿 관련 설정 파일로 URL과 관련된 설정 파일이다
    - `InternalResourceViewResolver`, `<context:component-scan/>`, `<annotation-driven>`, `<resources>`, `<beans:bean class="...">`, ...
    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <beans:beans xmlns="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:beans="http://www.springframework.org/schema/beans"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    
    <!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->
    
    <!-- Enables the Spring MVC @Controller programming model -->
    <annotation-driven />
    
    <!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
    <resources mapping="/resources/**" location="/resources/" />
    
    <!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
    <beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <beans:property name="prefix" value="/WEB-INF/views/" />
    <beans:property name="suffix" value=".jsp" />
    </beans:bean>
    
    <context:component-scan base-package="com.company.devpad" />
    </beans:beans>
    ```

각 태그의 세부내용은 다음과 같다.

`InternalResourceViewResolver`는 서블릿 설정으로 prefix(접두사)와 suffix(접미사)를 붙여주는 역할을 한다. <br>
**즉, 우리가 일일이 전체경로와 .jsp를 붙이지 않도록 도와준다**
`<context:component-scan/>`은 스프링에서 사용하는 bean을 일일이 xml에 선언하지 않고도 필요한 것을 어노테이션(@, Annotaion)을 자동으로 인식하게 하는 역할을 한다.<br>
**즉, Java 파일의 @Component로 등록된 Bean 객체를 찾도록 해주는 태그** <br>
`<annotation-driven>`은 @Controller 어노테이션을 감지하여 해당 클래스를 Controller로 등록할 수 있도록 해주는 태그 
`<resources>` : 정적인 html문서 같은 웹 리소스들의 정보를 기술하는 태그 <br>
`<beans:bean class="org.springframework.web.servlet.view.InternalResourceBiewResolver">` : Controller가 Model를 리턴하고 DispatcherServlet이 jsp 파일을 찾을 때 쓰이는 정보를 기술하는 태그. "home"이라는 문자열을 반환하면 /WEB-INF/views/ 경로에서 접미사가 .jsp인 해당 파일을 찾는다. <br>
**ㄴ /WEB-INF/views/** home **.jsp** 

<br>

* root-context.xml
    - VIEW와 관련되지 않은 객체를 정의하게 되는데 Service, Repository(DAO), DB 등 비지니스 로직과 관련된 설정을 한다  

    
    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- Root Context: defines shared resources visible to all other web components -->
    
    </beans>
    ```




---

#### **스프링 프로젝트 실행 과정**
![image](https://user-images.githubusercontent.com/64416833/141066707-f2fdc78f-538d-4a3e-9bba-86f5b38a709b.png)
3. 순수한 데이터 처리 로직은 root-context.xml의 영역이고 처리되어 받는 데이터결과를 Model이라고 한다<br>

1) 사용자가 URL에 페이지를 요청 (Request)
2) Controller가 실제 DB에 있는 데이터를 가지고온다(순수한 데이터 처리 로직)<br>
ㄴ Model(DB에서 가져온 데이터들)
3) jsp화면에 Model(데이터들)을 전달(처리된 데이터를 View로 전달)
4) 전달된 화면을 가지고 브라우저에 맞는 메시지를 만든다(Tomcat의 역할)
5) Tomcat을 통해 브라우저에 화면을 뿌려준다(Response)

--- 
<br>

**자세한 스프링 실행 순서**

![image](https://user-images.githubusercontent.com/64416833/141066170-be32a7d9-f84f-4eee-b856-a0f97b1d1605.png)

1. 클라이언트가 Request 요청을 하면, DispatcherServlet이 요청을 가로챈다. 이 때 DispatcherServlet이 모든 요청을 가로채는 건 아니고 web.xml에 등록된 내용만 가로챈다. 최초의 web.xml 에서는 <url-pattern>이 '/'와 같이 해당 애플리케이션의 모든 URL로 등록돼있기 때문에, 만약 *. do와 같이 특정 URL만 적용하고 싶다면 <url-pattern>의 내용을 바꿔주어 범위를 변경하면 된다.

2. DispatcherServlet이 가로챈 요청을 HandlerMapping에게 보내 해당 요청을 처리할 수 있는 Controller를 찾는다.

3. 실제 로직 처리 (Controller -> Service -> DAO -> DB -> DAO -> Service -> Controller)

4. 로직 처리 후 ViewResolver를 통해 view 화면을 찾는다.

5. 찾은 view 화면을 View에 보내면 이 결과를 다시 DispatcherServlet에 보내고, DispatcherServlet는 최종 클라이언트에게 전송한다.

[참고자료] https://devpad.tistory.com/24

<br><br>

---

<br>

### 2. ApplicationContext

<br><br>

### 3. 비지니스 로직
비지니스 로직을 예시로 이해하면 쉽다.

유저가 홈페이지에 회원가입을 한다고 가정해보자.<br>
유저는 회원가입 양식 폼에 회원정보를 작성하고, 회원가입 버튼을 누르면 회원가입이 진행된다. <br>

유저 입장에서는 폼의 양식과 제출 버튼으로 중복/인증의 과정을 단순하게 확인이 가능하지만 프로그래머는 중복/인증과 관련한 일련의 과정들을 구현해야 한다.

과정들을 아래와 같을 것이다.<br>
1. 유저가 입력한 아이디가 가입한 회원 중 동일한 아이디가 있는지 확인한다
2. 본인의 인증이 올바른지 확인한다
3. 로그인 시 아이디와 매칭되는 비밀번호가 올바른지 확인한다
그 외 여러 과정들이 존재한다.

위 과정들은 두 가지 영으로 나눌 수 있습니다.<br>
1. 중복/인증을 검사하는 일련의 과정들
2. 유저에게 단순히 텍스트나 다이얼로그로 나타내는 과정들

**1번의 과정**은 데이터 가공을 담당하는 것이 로직 영역 또는 모델 영역이라고 부르고 **2번의 과정**은 가공된 데이터를 단순히 표시만 해주는 프레젠테이션 영역 또는 뷰 영역이라고 부른다

두 과정 중 1번의 과정이 코딩에서 흔히, **비지니스 로직**이라고 부른다.

위 3개의 예시 중 1번인 아이디 중복을 예시로 들자면 아래와 같은 비지니스 로직이 작성될 것이다.
<br>

1. 유저가 작성한 아이디 값을 저장
2. 회원 정보가 있는 데이터베이스와 연결
3. 데이터베이스에 유저가 입력한 아이디와 중복된 아이디가 있는지 검색
4. 중복 아이디 유무에 따라 데이터화하여 저장
5. 데이터베이스와의 연결 끊기
6. View영역에 가공된 데이터 전달

즉, 이러한 과정들이 비지니스 로직이다.
정리하면 **비지니스 로직은 유저 눈에 보이지 않지만 유저가 바라는 결과물을 올바르게 도출하기 위해 짜여진 코드들** 이라고 할 수 있다.

[참고자료] https://mommoo.tistory.com/67
<br><br>

---




<br>

### 4. `<dependencies>`
[참고자료] https://araikuma.tistory.com/447

---

<br><br>

### 5. System.out.print보다 log가 권장되는 이유
들어가기에 앞서 logger의 정의는 아래와 같다. <br>

로깅(logging) : 로그를 기록하는 행위 <br>
[출처 : https://ko.wikipedia.org/wiki/%EB%A1%9C%EA%B7%B8%ED%8C%8C%EC%9D%BC ] 

<br>

기본적으로 콘솔에 출력이라 하면 `System.out.println()` 을 생각할 것이다. <br>

그러나 로깅에서 위 코드를 사용하는 바람직하지 못하다.

---

System.out.println은 예제 프로그램 등 간단한 것에는 무관하나, 실제로 사용자가 있는 프로젝트 환경에서는 사용을 지양하여야 한다.

---

<br>

이유는 아래와 같다

1. System.out.println()으로 디버그 정보를 출력하면 인자 값만 출력해준다. 즉, 최소한의 로그 정보가 없다고 할 수 있다.<br><br>
로깅 라이브러리(log4j, slf4j 등)를 사용하면 날짜/시간/로그 생성자/타입 등을 함께 출력해주는데 System.out.println()은 그렇지 않다. 이런 기본적인 로그 데이터가 장애가 발생했을 때 추적할 수 있게 해주는 정보원이기 때문이다.
<br>

2. 로그 정보를 가져오기 어렵다. <br>
System.out.println() 메소드는 콘솔에 로그를 출력하는 API이다. 이미 콘솔에 출력한 내용들을 파일로 가져오거나 서버로 전송하는데 어려움이 있다. 억지를 부리면, 파일로 못출력할거야 없지만 굉장히 번거로울 것이다.<br>

3. 성능에 영향을 많이준다. <br>
 println은 CPU 리소스를 점유하게 된다. 개발 시에 로깅 라이브러리는 DEBUG레벨로 사용하다가 운영시 INFO레벨로 바꾸면 되겠지만 System.out.println()는 개발시에 실수로라도 남겨두게 된다면 후에 운영시 계속 작동하여 서버나 프로그램 성능에 영향을 끼치게 될 것이다.

 <br>

 이러한 이유가 아니더라도 협업하는 개발자/운영자를 위해 println()은 지양하고 로깅 라이브러리를 사용하는 것이 바람직하다<br>

 [참고자료] https://jong99.tistory.com/109

<br><br>


# **-- 추후 추가예정 --**

<br>

### 6. 인터페이스의 장점과 쓰는 이유

<br>

---

<br>

### 7. jUnit(@Test)의 역할

<br>

--- 

<br>

### 8. spring<->mysql과 spring<->oracle접속
<br>

---

<br>

### 9. mapper 사용 이유
<br>

---

<br>

### 10. VO, DTO, DAO, Mapper
<br>

---

<br>

### 11. sqlSessionFactory
<br>

---

<br>

### 12. ns(namespaces)란
<br>

---

<br>

### 13. 커넥션 풀(Connection Pool)
<br>

---
