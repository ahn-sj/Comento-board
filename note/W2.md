### 1. 스프링 프로젝트 기본 구조 및 실행 과정

#### **스프링 프로젝트 기본 구조**

![image](https://user-images.githubusercontent.com/64416833/141065916-fa6fca38-ccee-4b60-aec7-b7c35d6b6836.png)

1. web.xml
2. root-context.xml / servlet-conext.xml load
3. servlet-context에 명시된 controller address mapping
4. Controller 내부 메서드 실행<br><br>

* web.xml (서블릿 배포 기술자, DD(Deployment Descriptor))
    - WAS(Tomcat)가 최초로 구동될 때 WEB-INF/ 디렉터리에 존재하는 web.xml을 읽고 그에 해당하는 웹 애플리케이션 설정을 구성한다. 
    <br>다시 말해, **각종 설정을 위한 설정파일**이다.<br>
    - 여러 xml파일(기본 : root-context.xml / servlet-context.xml)을 인식하도록 각 파일을 가리켜준다

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
 
    <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/spring/root-context.xml</param-value>
 </context-param>
 
    <!-- Creates the Spring Container shared by all Servlets and Filters -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
 
    <!-- Processes application requests -->
    <servlet>
        <servlet-name>appServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
 
    <servlet-mapping>
        <servlet-name>appServlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

각 태그의 세부내용은 다음과 같다.

`<servlet>` : DispatcherServlet을 구현하기 위해 어떤 클래스를 이용해야 할지와 초기 파라미터 정보를 포함하고 있다. <br>
`<servlet-name>` : 해당 서블렛의 이름을 지정하면 이 지정된 이름을 가지고 다른 설정 파일에서 해당 서블릿 정보를 참조한다. <br>
`<servlet-class>` : 어떤 클래스를 가지고 DispatcherServlet을 구현할 것인지를 명시하고 있다. <br>
`<init-param>`  : 초기화 파라미터에 대한 정보. servlet에 대한 설정 정보가 여기에 들어간다. 만약 초기화 파라미터에 대한 정보를 기술하지 않을 경우 스프링이 자동적으로 appServlet-context.xml을 이용하여 스프링 컨테이너를 생성한다. <br>
`<load-on-startup>` :  서블릿이 로딩될 때 로딩 순서를 결정하는 값. 톰캣이 구동되고 서블릿이 로딩되기 전 해당 서블릿에 요청이 들어오면 서블릿이 구동되기 전까지 기다려야 한다. 이 중 우선순위가 높은 서블릿부터 구동할 때 쓰이는 값이다. <br>
`<servlet-mapping>` : 서블렛이 <url-pattern>에서 지정한 패턴으로 클라이언트 요청이 들어오면 해당 <servlet-name>을 가진 servlet에게 이 요청을 토스하는 정보를 기술한다. <br>


* root-context.xml
    - VIEW와 관련되지 않은 객체를 정의하게 되는데 Service, Repository(DAO), DB 등 비지니스 로직과 관련된 설정을 한다  

    
```xml
<?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <!-- Root Context: defines shared resources visible to all other web components -->
</beans>
```


* servlet-context.xml
    - 서블릿 관련 설정 파일로 URL과 관련된 설정 파일이다
    - `InternalResourceViewResolver`, `<context:component-scan/>`, `<annotation-driven>`, `<resources>`, `<beans:bean class="...">`, ...

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:beans="http://www.springframework.org/schema/beans"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/mvc 
        https://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/beans 
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        https://www.springframework.org/schema/context/spring-context.xsd">
    
    <!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->
    
    <!-- Enables the Spring MVC @Controller programming model -->
    <annotation-driven />
    
    <!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
    <resources mapping="/resources/**" location="/resources/" />
    
    <!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
    <beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <beans:property name="prefix" value="/WEB-INF/views/" />
        <beans:property name="suffix" value=".jsp" />
    </beans:bean>
    
    <context:component-scan base-package="com.company.devpad" />
    </beans:beans>
```

각 태그의 세부내용은 다음과 같다.

`InternalResourceViewResolver`는 서블릿 설정으로 prefix(접두사)와 suffix(접미사)를 붙여주는 역할을 한다. <br>
**즉, 우리가 일일이 전체경로와 .jsp를 붙이지 않도록 도와준다**
`<context:component-scan/>`은 스프링에서 사용하는 bean을 일일이 xml에 선언하지 않고도 필요한 것을 어노테이션(@, Annotaion)을 자동으로 인식하게 하는 역할을 한다.<br>
**즉, Java 파일의 @Component로 등록된 Bean 객체를 찾도록 해주는 태그** <br>
`<annotation-driven>`은 @Controller 어노테이션을 감지하여 해당 클래스를 Controller로 등록할 수 있도록 해주는 태그 
`<resources>` : 정적인 html문서 같은 웹 리소스들의 정보를 기술하는 태그 <br>
`<beans:bean class="org.springframework.web.servlet.view.InternalResourceBiewResolver">` : Controller가 Model를 리턴하고 DispatcherServlet이 jsp 파일을 찾을 때 쓰이는 정보를 기술하는 태그. "home"이라는 문자열을 반환하면 /WEB-INF/views/ 경로에서 접미사가 .jsp인 해당 파일을 찾는다. <br>
**ㄴ /WEB-INF/views/** home **.jsp** 

<br>






---

#### **스프링 프로젝트 실행 과정**
![image](https://user-images.githubusercontent.com/64416833/141066707-f2fdc78f-538d-4a3e-9bba-86f5b38a709b.png)
3. 순수한 데이터 처리 로직은 root-context.xml의 영역이고 처리되어 받는 데이터결과를 Model이라고 한다<br>

1) 사용자가 URL에 페이지를 요청 (Request)
2) Controller가 실제 DB에 있는 데이터를 가지고온다(순수한 데이터 처리 로직)<br>
ㄴ Model(DB에서 가져온 데이터들)
3) jsp화면에 Model(데이터들)을 전달(처리된 데이터를 View로 전달)
4) 전달된 화면을 가지고 브라우저에 맞는 메시지를 만든다(Tomcat의 역할)
5) Tomcat을 통해 브라우저에 화면을 뿌려준다(Response)

--- 
<br>

**자세한 스프링 실행 순서**

![image](https://user-images.githubusercontent.com/64416833/141066170-be32a7d9-f84f-4eee-b856-a0f97b1d1605.png)

1. 클라이언트가 Request 요청을 하면, DispatcherServlet이 요청을 가로챈다. 이 때 DispatcherServlet이 모든 요청을 가로채는 건 아니고 web.xml에 등록된 내용만 가로챈다. 최초의 web.xml 에서는 <url-pattern>이 '/'와 같이 해당 애플리케이션의 모든 URL로 등록돼있기 때문에, 만약 *. do와 같이 특정 URL만 적용하고 싶다면 <url-pattern>의 내용을 바꿔주어 범위를 변경하면 된다.

2. DispatcherServlet이 가로챈 요청을 HandlerMapping에게 보내 해당 요청을 처리할 수 있는 Controller를 찾는다.

3. 실제 로직 처리 (Controller -> Service -> DAO -> DB -> DAO -> Service -> Controller)

4. 로직 처리 후 ViewResolver를 통해 view 화면을 찾는다.

5. 찾은 view 화면을 View에 보내면 이 결과를 다시 DispatcherServlet에 보내고, DispatcherServlet는 최종 클라이언트에게 전송한다.

[참고자료] https://devpad.tistory.com/24

<br><br>

---

<br>

### 2. ApplicationContext

<br><br>

### 3. 비지니스 로직
비지니스 로직을 예시로 이해하면 쉽다.

유저가 홈페이지에 회원가입을 한다고 가정해보자.<br>
유저는 회원가입 양식 폼에 회원정보를 작성하고, 회원가입 버튼을 누르면 회원가입이 진행된다. <br>

유저 입장에서는 폼의 양식과 제출 버튼으로 중복/인증의 과정을 단순하게 확인이 가능하지만 프로그래머는 중복/인증과 관련한 일련의 과정들을 구현해야 한다.

과정들을 아래와 같을 것이다.<br>
1. 유저가 입력한 아이디가 가입한 회원 중 동일한 아이디가 있는지 확인한다
2. 본인의 인증이 올바른지 확인한다
3. 로그인 시 아이디와 매칭되는 비밀번호가 올바른지 확인한다
그 외 여러 과정들이 존재한다.

위 과정들은 두 가지 영으로 나눌 수 있습니다.<br>
1. 중복/인증을 검사하는 일련의 과정들
2. 유저에게 단순히 텍스트나 다이얼로그로 나타내는 과정들

**1번의 과정**은 데이터 가공을 담당하는 것이 로직 영역 또는 모델 영역이라고 부르고 **2번의 과정**은 가공된 데이터를 단순히 표시만 해주는 프레젠테이션 영역 또는 뷰 영역이라고 부른다

두 과정 중 1번의 과정이 코딩에서 흔히, **비지니스 로직**이라고 부른다.

위 3개의 예시 중 1번인 아이디 중복을 예시로 들자면 아래와 같은 비지니스 로직이 작성될 것이다.
<br>

1. 유저가 작성한 아이디 값을 저장
2. 회원 정보가 있는 데이터베이스와 연결
3. 데이터베이스에 유저가 입력한 아이디와 중복된 아이디가 있는지 검색
4. 중복 아이디 유무에 따라 데이터화하여 저장
5. 데이터베이스와의 연결 끊기
6. View영역에 가공된 데이터 전달

즉, 이러한 과정들이 비지니스 로직이다.
정리하면 **비지니스 로직은 유저 눈에 보이지 않지만 유저가 바라는 결과물을 올바르게 도출하기 위해 짜여진 코드들** 이라고 할 수 있다.

[참고자료] https://mommoo.tistory.com/67
<br><br>

---




<br>

### 4. `<dependencies>`
[참고자료] https://araikuma.tistory.com/447

---

<br><br>

### 5. System.out.print보다 log가 권장되는 이유
들어가기에 앞서 logger의 정의는 아래와 같다. <br>

로깅(logging) : 로그를 기록하는 행위 <br>
[출처 : https://ko.wikipedia.org/wiki/%EB%A1%9C%EA%B7%B8%ED%8C%8C%EC%9D%BC ] 

<br>

기본적으로 콘솔에 출력이라 하면 `System.out.println()` 을 생각할 것이다. <br>

그러나 로깅에서 위 코드를 사용하는 바람직하지 못하다.

---

System.out.println은 예제 프로그램 등 간단한 것에는 무관하나, 실제로 사용자가 있는 프로젝트 환경에서는 사용을 지양하여야 한다.

---

<br>

이유는 아래와 같다

1. System.out.println()으로 디버그 정보를 출력하면 인자 값만 출력해준다. 즉, 최소한의 로그 정보가 없다고 할 수 있다.<br><br>
로깅 라이브러리(log4j, slf4j 등)를 사용하면 날짜/시간/로그 생성자/타입 등을 함께 출력해주는데 System.out.println()은 그렇지 않다. 이런 기본적인 로그 데이터가 장애가 발생했을 때 추적할 수 있게 해주는 정보원이기 때문이다.
<br>

2. 로그 정보를 가져오기 어렵다. <br>
System.out.println() 메소드는 콘솔에 로그를 출력하는 API이다. 이미 콘솔에 출력한 내용들을 파일로 가져오거나 서버로 전송하는데 어려움이 있다. 억지를 부리면, 파일로 못출력할거야 없지만 굉장히 번거로울 것이다.<br>

3. 성능에 영향을 많이준다. <br>
 println은 CPU 리소스를 점유하게 된다. 개발 시에 로깅 라이브러리는 DEBUG레벨로 사용하다가 운영시 INFO레벨로 바꾸면 되겠지만 System.out.println()는 개발시에 실수로라도 남겨두게 된다면 후에 운영시 계속 작동하여 서버나 프로그램 성능에 영향을 끼치게 될 것이다.

 <br>

 이러한 이유가 아니더라도 협업하는 개발자/운영자를 위해 println()은 지양하고 로깅 라이브러리를 사용하는 것이 바람직하다<br>

 [참고자료] https://jong99.tistory.com/109

<br><br>


# **-- 추후 추가예정 --**

<br>

### 6. 인터페이스의 장점과 쓰는 이유

<br>

---

<br>

### 7. jUnit(@Test)의 역할

<br>

--- 

<br>

### 8. spring<->mysql과 spring<->oracle접속
<br>

---

<br>

### 9. mapper 사용 이유
<br>

---

<br>

### 10. DAO, DTO, VO, Entity
- DAO(Data Access Object)
    - 데이터베이스의 데이터에 접근하기 위한 클래스
    - 직접 데이터베이스에 접근하여 데이터를 삽입, 삭제, 조회 등 조작할 수 있는 기능을 수행
    - 데이터베이스에 접근하기 위한 로직과 비지니스 로직을 분리하기 위해 사용
    - DB에 대한 접근을 DAO가 담당하도록 하여 데이터베이스 엑세스를 DAO에서만 하게 되면 다수의 원격호출을 통한 오버헤드를 VO나 DTO를 통해 줄일 수 있고 다수의 DB 호출문제를 해결할 수 있습니다. 또한 단순히 읽기만 하는 연산이므로 트랜잭션 간의 오버헤드를 감소할 수 있습니다.
    - Database의 데이터에 접근하는 트랜잭션 객체이다. 즉, DB에 접근하여 데이터를 조회, 조작하는 기능을 전담한다.
    - 데이터베이스와 연결할 Connection까지 설정되어 있는 경우가 많다.  <br>
    ㄴ그러나, 현재 많이 쓰이는 MyBatis등을 사용할 경우 커넥션풀까지 제공되기 때문에 DAO를 별도로 만드는 경우는 드물다.<br>
    TIP) 웹서버는 데이터베이스와 연결하기 위해 매번 커넥션 객체를 생성하는데 이걸 매번 생성하기 번거롭기 때문에 이를 해결하기 위해 나온것이 커넥션 풀이다. 커넥션 풀은 커넥션 객체를 미리 만들어놓고 그것을 가져다 쓰고 다 쓴 후에는 반환해주는 작업을 자동으로 해준다.
    - 예를들자면, DB에 접속하여 데이터의 CRUD(생성, 읽기, 갱신, 삭제) 작업을 시행하는 클래스라고 할 수 있다
    - 사용하는 이유는 다음과 같다
    ㄴ 사용하는 이유는 효율적인 커넥션 관리와 보안성, 저수준의 로직과 고급 비즈니스 로직을 분리하고, Domain 로직으로부터 DB관련 mechanism을 숨기기 위해 사용한다. 

- DTO(Data Transfer Object)
    - **계층간(Controller(Business Layer), View(Persistense Layer)) 데이터 교환을 위한 객체(Java Beans)를 의미**
    - **DTO는 로직을 가지지 않는 순수한 데이터 객체이고 객체의 속성과 그 속성에 접근을 위한 getter/setter 메서드만을 가진 클래스**
    - 주로 비동기 처리를 할 때 사용되며 데이터베이스의 데이터를 Service나 Controller등으로 보낼 때 사용하는 객체
    - 가변의 성격을 가진 클래스로 데이터전송을 위해 존재한다(getter/setter)
    - DTO는 보통 로직을 가지고 있지않고 데이터에 접근을 위한 getter/setter만을 가지고 있다
    - 정리하면, DTO는 데이터베이스에서 데이터를 얻어 Service나 Controller등으로 보낼 때 사용하는 객체
    - 아래와 같은 예시를 들 수 있다.
        - 유저가 자신의 브라우저에서 데이터를 입력하여 form에 있는 데이터를 DTO에 넣어서 전송합니다.
        - 해당 DTO를 받은 서버가 DAO를 이용하여 데이터베이스로 데이터를 집어넣습니다.


- VO(Value Object)
    - DTO와 달리 VO는 값 그 자체의 의미를 가진 불변 클래스(Read-Only)의 특징을 가진 클래스
    - 보통 getter의 기능만을 포함한다

- Entity
    - Entity클래스는 실제 데이터베이스의 테이블과 1:1로 매핑되는 클래스로 DB의 테이블 내에 존재하는 (모든)컬럼을 속성(필드)으로 가져야 한다.
    - Entity와 DTO를 분리해서 관리해야 하는 이유는 DB Layer와 View Layer 사이의 역할을 분리 하기 위해서다.<br>
    ㄴ Entity 클래스는 실제 테이블과 매핑되어 만일 변경되게 되면 여러 다른 클래스에 영향을 끼치고, DTO 클래스는 View와 통신하며 자주 변경되므로 분리 해주어야 한다.
    
---

- DTO와 VO
VO는 테이블의 로직 자체를 말하는 것 같고 DTO는 데이터 요청/응답시에 필요한 데이터만을 위해 존재하는 클래스이다. <br><br>
DTO의 역할은 데이터 요청/응답시에 필요한 데이터를 입/출력하는 것이 목적이기 때문에 getter/setter메서드외에 존재하면 안된다. <br>
VO의 역할은 테이블의 컬럼 자체를 말하는 것이기 때문에 데이터를 그대로 가져오는 경우에 사용한다.

- 공통점으로는 넣어진 데이터를 getter를 통해 사용하므로 주 목적이 같으나 DAO는 가변적인 성격을 가진 클래스이며(setter) 그에 비해 VO는 불변의 성격을 가진 차이점이 존재한다
<br>

---

<br>

코드 예시
```java
// DAO클래스 예제
// 1. DB와 연결할 Connection을 가져온다.
// 2. 어떤 DB를 사용할 것이며, 어떤 드라이브와 로그인 정보를 사용할 것인가.
// 3. 작업이 끝나면 사용한 리소스를 시스템에 돌려준다.
public class TestDao {

    public void add(TestDto dto) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection connection = DriverManager.getConnection("jdbc:mysql://localhost/test", "root", "root");

        PreparedStatement preparedStatement = connection.prepareStatement("insert into users(id,name,password) value(?,?,?)");


        preparedStatement.setString(1, dto.getName());
        preparedStatement.setInt(2, dto.getValue());
        preparedStatement.setString(3, dto.getData());
        preparedStatement.executeUpdate();
        preparedStatement.close();
        
        connection.close();

    }
}

// DTD클래스 예제
public class TestDTO {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

여기서 중요한건 property개념인데 자바는 property가 문법적으로 제공되지 않는다.

자바에서 property개념을 사용하기 위해 지켜야 할 약속이 있다.
1. setter/getter에서 setXXX/getXXX에서 XXX에 해당하는 단어가 property로 약속한다.
이러한 이유로 위 클래스에서 property는 name과 age이다.

중요한 것은 property가 멤버변수 name, age에 의해 결정되는 것이 아니라 getter/setter에 의해 결정된다는 것이다.
즉, 멤버변수는 아무렇게 지어도 영향이 없고 getter/setter로 property로 표현한다.

이러한 것을 데이터 자동화 처리를 위해 자바 기본 프레임워크인 리플렉션 기법이 사용된다.

이러한 이유 때문에 layer간(특히 Controller->View 등)에 데이터를 넘길때 DTO를 쓰면 편하다는 것이 이러한 이유때문이다




---

Service
- service의 역할을 DAO가 DB에서 받아온 데이터를 전달받아 가공하는 것이다.

---

URL Request -> Controller <-> service <-> DAO <-> VO
- 흐름은 아래와 같다
Request -> Controller -> Service(interface) -> ServiceImpl -> DAO(interface) -> DAOImpl -> Service -> View

- 궁금점 DAO의 과정을 MyBatis(Mapper)가 대신하는 건지?

- DAO를 사용한 방법과 Mapper인터페이스를 사용하는 방법의 차이
ㄴ 1) 클라이언트 - Controller - Service - DAO(인터페이스와 인터페이스를 구현한 클래스) - mapper.xml 의 형식이었다. <br>
DAO 대신 Mapper를 사용하면,<br>
ㄴ 2) 클라이언트 - Controller - Service - Mapper.java(인터페이스) - mapper.xml 의 구조 형식이다.<br>


---

<br>

Mapper인터페이스를 사용하지 않을 경우
- SqlSession을 등록해줘야 한다.
- DAO인터페이스와 인터페이스를 구현한 DAO클래스를 생성해줘야한다. 
- Mapper인터페이스를 사용하지 않았을 때는 네임스페이스 + “.” + SQL ID로 지정해서 SQL을 호출해야한다.(예를들면 sesseion.selectOne(“com.test.mapper.TimeMapper.getReplyer, bno ))
- selectOne, insert, delete 등 제공하는 메소드를 사용해야 한다.
- 문자열로 작성하기 때문에 버그가 생길 수 있다.
- IDE에서 제공하는 code assist를 사용할 수 없다.

<br><br>

Mapper인터페이스를 사용하는 방법
- Mapper인터페이스는 개발자가 직접 작성한다.
- mapper 네임스페이스는 패키지명을 포함한 인터페이스 명으로 작성한다.
- SQL id는 인터페이스에 정의된 메서드명과 동일하게 작성한다<br>
[참고자료] https://doongjun.tistory.com/43

---

- 이것도 자세하게 설명되어 있어서 짱짱좋음
[참고자료] https://www.popit.kr/%EC%8B%A0%EC%9E%85-%EA%B0%9C%EB%B0%9C%EC%9E%90-%ED%95%99%EC%83%9D%EC%9D%84-%EC%9C%84%ED%95%9C-spring-mvc-setting-2%ED%8E%B8/ <br>

- 이게 찐 찐 찐 -> 요거로 정리해서 올리도록 하자
[참고자료] https://dalpaeng00.tistory.com/83

- 예로들면 클라이언트가 HTTP로 "컴퓨터 주문"을 요청해왔다고 하자. 이 "컴퓨터 주문"을 처리할 해당 URL이 있을 것이고 해당 URL에 대한 컨트롤러가 작동할 것이다. 그리고 "컴퓨터 주문"도 노트북 혹은 데스크탑, 고수준인지 저수준인지를 체크하는 세부 사항이 있을 것이고 그것을 다루는 계층이 서비스 계층의 서비스 객체다. DAO는 이 요청에 필요한 컴퓨터와 사용자 정보 데이터를 데이터베이스에서 가져오는 역할을 전담한다. 그리고 각 레이어 간에 데이터들은 VO로서 전달된다.
[참고자료] https://engkimbs.tistory.com/692
<br>

---
---

<br>

### 11. sqlSessionFactory
<br>

---

<br>

### 12. ns(namespaces)란
<br>

---

<br>

### 13. 커넥션 풀(Connection Pool)
<br>

---
